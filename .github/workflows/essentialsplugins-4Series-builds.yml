name: Essentials Plugin Build 4-Series

on:
  workflow_call:
    inputs:
      newVersion:
        description: 'New version?'
        required: true
        type: string
      version:
        description: 'The version of the file to build and push.'
        required: true
        type: string
      tag:
        description: 'The tag of the image to build and push.'
        required: true
        type: string
      channel:
        description: 'The channel of the image to build and push.'
        required: true
        type: string
      bypassPackageCheck:
        description: 'Set to true to bypass the package name check.'
        required: false
        type: boolean
  # workflow_dispatch:
  #   inputs:
  #     newVersion:
  #       description: 'New version?'
  #       required: true
  #       type: string
  #       default: 'false'
  #     version:
  #       description: 'The version of the file to build and push.'
  #       required: true
  #       type: string
  #       default: '1.0.0'
  #     tag:
  #       description: 'The tag of the image to build and push.'
  #       required: true
  #       type: string
  #       default: 'v1.0.0'
  #     channel:
  #       description: 'The channel of the image to build and push.'
  #       required: true
  #       type: string
  #       default: ''
  #     bypassPackageCheck:
  #       description: 'Set to true to bypass the package name check.'
  #       required: false
  #       type: boolean
  #       default: false
      
env:
  BUILD_TYPE: ${{ inputs.channel == '' && 'Release' || 'Debug' }}
jobs:
  Build_Project_4-Series:
    runs-on: windows-latest
    steps:
      # ---------------------------
      - name: Checkout repo
        uses: actions/checkout@v4     

      # ---------------------------
      - name: Get SLN Info
        id: get_sln_info
        shell: powershell
        run: |
          $solution_file = Get-ChildItem .\*.4Series.sln -recurse
          Write-Output $solution_file
          echo "SOLUTION_FILE=$($solution_file.BaseName)"| Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

          $solution_path = Get-ChildItem *.4Series.sln -recurse 
          $solution_path = $solution_path.FullName
          $solution_path = $solution_path -replace "(?:[^\\]*\\){4}", ""
          Write-Output $solution_path
          echo "SOLUTION_PATH=$($solution_path)" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append          

      # ---------------------------
      - name: Build Solution       
        id: build
        shell: powershell
        run: |
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "## Build Solution`n"
          
          # updated msbuild to use dotnet build, which also inlcudes the dotnet restore step
          $buildOutput = dotnet build .\${{ steps.get_sln_info.outputs.SOLUTION_FILE }}.sln /p:Platform="Any CPU" /p:Configuration="$($ENV:BUILD_TYPE)" /p:Version="${{ inputs.version }}" /p:IncludeSourceRevisionInInformationalVersion=false -m 2>&1

          # Display output
          $buildOutput | Out-String | Write-Output
          
          # Save build output to file
          $buildOutput | Out-String | Out-File -FilePath "build-output.log" -Encoding utf8
          
          # Check for build success
          if ($LASTEXITCODE -eq 0) {
            Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "**BUILD SUCCESS**`n"
            Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "- **Configuration**: $($ENV:BUILD_TYPE)`n"
            Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "- **Version**: ${{ inputs.version }}`n"
            Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "- **Solution**: ${{ steps.get_sln_info.outputs.SOLUTION_FILE }}.sln`n"
            Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "- **Build Log**: [Download build-output-log.zip](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})`n"
          } else {
            Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "**BUILD FAILED** - Exit code: $LASTEXITCODE`n"
            Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "Check the step logs above for detailed error information.`n"
            Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "- **Build Log**: [Download build-output-log.zip](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})`n"
            exit $LASTEXITCODE
          }   

      # ---------------------------
      - name: Clean up after failed build
        if: failure()
        shell: powershell
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $ErrorActionPreference = 'Continue'
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "## Build Failed Clean up`n"
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "The build output above shows the specific errors that caused the build to fail.`n`n"
          
          # Delete the release if it exists
          Write-Output "Checking for release with tag '${{ inputs.tag }}'..."
          $releaseJson = gh api repos/${{ github.repository }}/releases/tags/${{ inputs.tag }} 2>&1 | Out-String
          if ($LASTEXITCODE -eq 0) {
            $release = $releaseJson | ConvertFrom-Json
            Write-Output "Deleting release: $($release.name) (ID: $($release.id))"
            gh api -X DELETE repos/${{ github.repository }}/releases/$($release.id) 2>&1 | Out-String | Write-Output
            Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "Deleted release ``$($release.name)```n"
          }
          else {
            Write-Output "No release found for tag '${{ inputs.tag }}', skipping delete."
          }          

          # Check if tag exists on remote and delete it
          $tagExists = git ls-remote --tags origin "${{ inputs.tag }}" 2>&1
          if ($tagExists -match "${{ inputs.tag }}") {
            Write-Output "Deleting tag '${{ inputs.tag }}' from remote..."
            $ErrorActionPreference = 'SilentlyContinue'
            $output = git push origin --delete "${{ inputs.tag }}" 2>&1
            $exitCode = $LASTEXITCODE
            $ErrorActionPreference = 'Continue'
            $output | Out-String | Write-Output
            if ($exitCode -eq 0) {
              Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "Deleted tag ``${{ inputs.tag }}`` from remote.`n"
            }
            else {
              Write-Output "Failed to delete tag '${{ inputs.tag }}' from remote."
            }
          }
          else {
            Write-Output "Tag '${{ inputs.tag }}' does not exist on remote, skipping delete."
          }
                    
          exit 1
      

      # ---------------------------
      - name: Upload Build Output
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-output-log
          path: build-output.log
          retention-days: 30
      

      # ---------------------------
      - name: Check Package Name
        if: success()
        continue-on-error: true
        shell: powershell
        run: |
          if ("${{ inputs.bypassPackageCheck }}" -eq "true") {
            Write-Output "Bypassing package name check."
            exit 0
          }

          # Extract the repository name
          $repoFullName = "${{ github.repository }}" # Full repository name, including owner
          $repoName = $repoFullName.Split('/')[-1] # Extracting the repository name part
      
          # Expected package name format: PepperDash.Essentials.Plugins.Make.Model
          $expectedPackageName = "PepperDash.Essentials.Plugins." + ($repoName -replace 'epi-', '').Replace('-', '.')

          # Debug output
          Write-Output "Repository Name: $repoName"
          Write-Output "Expected Package Name: $expectedPackageName"
      
          # Locate the generated NuGet package in the output directory
          $packageFile = Get-ChildItem -Path .\output -Filter *.nupkg -Recurse
          if ($null -eq $packageFile) {
            $msg = "No NuGet package found in the output directory. Please check if the build generated the package correctly."
            Write-Error $msg
            Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "## Check Package Name`n"
            Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "***Failed***`n$msg`n"
            exit 1
          }
      
          # Extract the package name from the file (ignore version)
          $packageName = [System.IO.Path]::GetFileNameWithoutExtension($packageFile.FullName) -replace '\.\d+.*$'
      
          # Compare the actual package name with the expected name (case insensitive)
          if ($packageName.ToLower() -ne $expectedPackageName.ToLower()) {
            $msg = "Package name mismatch: Expected '$expectedPackageName' but found '$packageName'. Ensure the package name follows the repository naming convention."
            Write-Error $msg
            Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "## Check Package Name`n"
            Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "***Failed***`n$msg`n"
            exit 1
          }
      
      # ---------------------------
      # Create the release on the source repo  
      - name: Get release notes
        if: success() && inputs.newVersion == 'true'
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: change-log

      # ---------------------------
      # Upload the release to the source repo
      - name: Upload Release
        if: success() && inputs.newVersion == 'true'
        continue-on-error: true
        id: create_release
        uses: ncipollo/release-action@v1
        with:
          allowUpdates: true
          artifacts: 'output\**\*.*(cpz|cplz)'          
          prerelease: ${{ inputs.channel != '' }}
          tag: ${{ inputs.tag }}
          commit: ${{ github.sha }}
          bodyFile: ./CHANGELOG.md
      
      # ---------------------------
      # Publish to GitHub Packages NuGet feed
      - name: Publish to GitHub Package Registry
        if: success() && inputs.newVersion == 'true'
        continue-on-error: true
        run: |
          if (-not (Test-Path -Path ".\output\*.nupkg")) {
            $msg = "No NuGet package found in the output directory. Check if the build process created the package correctly."
            Write-Error $msg
            Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "## Publish to GitHub Package Registry`n"
            Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "***ERROR***`n$msg`n"
            exit 1
          }          
          if (-not (nuget sources list | Select-String -Pattern "https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json")) {
            nuget sources add -name github -source https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json -username pepperdash -password ${{ secrets.GITHUB_TOKEN }}
          }
          
          try {
            Get-ChildItem -Path .\output -Recurse -Include *.nupkg | ForEach-Object {
              $packageName = $_.Name
              Write-Output "Pushing $packageName to GitHub feed..."
              nuget push $_.FullName -source github -apikey ${{ secrets.GITHUB_TOKEN }} -SkipDuplicate
            }
          }
          catch {
            $msg = "Failed to publish to GitHub feed: $($_.Exception.Message)"
            Write-Error $msg
            Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "## Publish to GitHub Package Registry`n"
            Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "***ERROR***`n$msg`n"
            exit 1
          }

      # ---------------------------
      # Publish to Nuget.org (public repos only)
      - name: Publish to Nuget.org (public repos only)
        if: success() && inputs.newVersion == 'true'
        continue-on-error: true
        run: |
          $owner = "${{ github.repository_owner }}"
          $visibility = "${{ github.event.repository.visibility }}"

          Write-Output "Repository Owner: $owner"
          Write-Output "Repository Visibility: $visibility"

          if ($owner.ToLower() -ne 'pepperdash' -or $visibility.ToLower() -ne 'public') {
            Write-Output "Repository is not public, skipping publishing to NuGet.org."
          }
          else {
            if (-not (Test-Path -Path ".\output\*.nupkg")) {
              $msg = "No NuGet package found in the output directory. Check if the build process created the package correctly."
              Write-Error $msg
              Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "## Publish to Nuget.org`n"
              Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "***ERROR***`n$msg`n"
              exit 0
            }
            
            Write-Output "Publishing ${{ github.repository }} to NuGet.org"
            nuget setApiKey ${{ secrets.NUGET_API_KEY }} -Source https://api.nuget.org/v3/index.json
            
            try {
              Get-ChildItem -Path .\output -Recurse -Include *.nupkg | ForEach-Object {
                $packageName = $_.Name
                Write-Output "Pushing $packageName to NuGet.org..."
                nuget push $_.FullName -Source https://api.nuget.org/v3/index.json -SkipDuplicate
              }
            }
            catch {
              $msg = "Failed to publish to NuGet.org: $($_.Exception.Message)"
              Write-Error $msg
              Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "## Publish to Nuget.org`n"
              Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "***ERROR***`n$msg`n"
              exit 1
            }
          }
