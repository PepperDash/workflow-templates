name: Essentials Plugin Build 3-Series

on:
  workflow_call:
    inputs:
      newVersion:
        description: 'new version?'
        required: true
        type: string
      version:
        description: 'The version of the file to build and push'
        required: true
        type: string
      tag:
        description: 'The tag of the image to build and push'
        required: true
        type: string
      channel:
        description: 'The channel of the image to build and push'
        required: true
        type: string 
permissions:
  contents: write
  packages: write
jobs:
  Build_Project_3-Series:
    runs-on: windows-2019
    env:
      VERSION: ${{ inputs.version }}
      BUILD_TYPE: ${{ inputs.channel == '' && 'Release' || 'Debug' }}
      NUSPEC_FILE: ''
    steps:
      # First we checkout the source repo
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
          # Fetch all tags
      - name: Fetch tags
        run: git fetch --tags
      
        # Update AssemblyInfo
      - name: Update AssemblyInfo.cs
        shell: pwsh
        run: |
          function Update-SourceVersion {
          Param ([string]$Version)
          #$fullVersion = $Version
          $baseVersion = [regex]::Match($Version, "(\d+.\d+.\d+).*").captures.groups[1].value
          $NewAssemblyVersion = 'AssemblyVersion("' + $baseVersion + '.*")'
          Write-Output "AssemblyVersion = $NewAssemblyVersion"
          $NewAssemblyInformationalVersion = 'AssemblyInformationalVersion("' + $Version + '")'
          Write-Output "AssemblyInformationalVersion = $NewAssemblyInformationalVersion"
          foreach ($o in $input) {
              Write-output $o.FullName
              $TmpFile = $o.FullName + ".tmp"
              get-content $o.FullName |
              ForEach-Object {
                  $_ -replace 'AssemblyVersion\(".*"\)', $NewAssemblyVersion } |
              ForEach-Object {
                  $_ -replace 'AssemblyInformationalVersion\(".*"\)', $NewAssemblyInformationalVersion
              }  > $TmpFile 
              move-item $TmpFile $o.FullName -force
            }
          }
          function Update-AllAssemblyInfoFiles ( $version ) {
              foreach ($file in "AssemblyInfo.cs", "AssemblyInfo.vb" ) {
                  get-childitem -Path $Env:GITHUB_WORKSPACE -recurse | Where-Object { $_.Name -eq $file } | Update-SourceVersion $version ;
              }
          }
          # validate arguments
          $r = [System.Text.RegularExpressions.Regex]::Match($Env:VERSION, "\d+\.\d+\.\d+.*");          
          if ($r.Success) {
              Write-Output "Updating Assembly Version to $Env:VERSION ...";
              Update-AllAssemblyInfoFiles $Env:VERSION;
          }
          else {
              Write-Output " ";
              Write-Output "Error: Input version $Env:VERSION does not match x.y.z format!"
              Write-Output " ";
              Write-Output "Unable to apply version to AssemblyInfo.cs files";
          }
      
      - name: restore Nuget Packages
        run: nuget install .\packages.config -OutputDirectory .\packages -ExcludeVersion
      
      # Login to Docker
      - name: Login to Docker
        uses: azure/docker-login@v1
        with:
          username: ${{ secrets.DOCKERHUB_USER }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}
        
      # Get the SLN Path & file
      - name: Get SLN Path & SLN File
        shell: pwsh
        run: |
          $workspace = $Env:GITHUB_WORKSPACE
          $searchPath = "*.3Series.sln"

          $solution_file = Get-ChildItem -Path $workspace -Filter $slnSearchPattern -Recurse

          Write-Output "Solution File: $($solution_file.BaseName)"
          Write-Output "Solution Path: $($solution_file.Name)"

          Write-Output "SOLUTION_FILE=$($solution_file.BaseName)" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          Write-Output "SOLUTION_PATH=$($solution_file.Name)" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append  

          Write-Output "Searching for .csproj references in $($solution_file.Name)..."
          $csprojPaths = @()
          # Regex to find Project lines and capture the relative csproj path
          $projectRegex = 'Project\("{[A-F0-9-]+}"\) = "[^"]+", "([^"]+\.csproj)", "{[A-F0-9-]+}"'

          Get-Content -Path $solution_file.FullName | ForEach-Object {
              if ($_ -match $projectRegex) {
                  $relativeCsprojPath = $Matches[1]
                  # Construct the full path relative to the SLN directory
                  $fullCsprojPath = Join-Path -Path $solution_file.DirectoryName -ChildPath $relativeCsprojPath
                  $csprojPaths += $fullCsprojPath
                  Write-Output "  Found CSPROJ reference: $relativeCsprojPath"
                  Write-Output "  Full CSPROJ Path: $fullCsprojPath"
              }
          }

          if ($csprojPaths.Count -eq 0) {
              Write-Warning "No .csproj references found in $($solution_file.Name)."
          } elseif ($csprojPaths.Count -gt 1) {
              Write-Warning "Multiple .csproj references found. You might need to adjust logic depending on which one is needed."
              # Example: Set an environment variable with the first one found
              # $firstCsproj = $csprojPaths[0]
              # Write-Output "CSPROJ_FILE=$firstCsproj" # | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          } else {
              # Exactly one found
              $csprojFile = $csprojPaths[0]
              $csprojFileName = Split-Path -Path $csprojFile -Leaf
              $csprojFileName = $csprojFileName -Replace ".csproj", "" -Replace ".3Series", ""
              Write-Output "CSPROJ_FILE=$csprojFile" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
              Write-Output "CSPROJ_FILE_NAME=$csprojFileName" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          }
                  

      # Build the solution using the docker image
      - name: Build Solution
        shell: powershell
        run: |
          Write-Output "Preparing to build solution`n- Solution File: $($Env:SOLUTION_FILE)`n- Solution Path: $($Env:SOLUTION_PATH)`n- Build Type: $($ENV:BUILD_TYPE)`n-Version: $($ENV:VERSION)`n- Workspace: $($Env:GITHUB_WORKSPACE)"
          Invoke-Expression "docker run --rm --mount type=bind,source=""$($Env:GITHUB_WORKSPACE)"",target=""c:\project"" pepperdash/sspbuilder c:\cihelpers\vsidebuild.exe -Solution ""c:\project\$($Env:SOLUTION_PATH)"" -BuildSolutionConfiguration $($ENV:BUILD_TYPE)"
      
      # Copy the build output files to the output directory      
      - name: Copy build output files
        shell: pwsh
        run: |
          # GitHub Actions environment variables
          $sourceDir = "$Env:GITHUB_WORKSPACE\src" 
          $destinationDir = "$Env:GITHUB_WORKSPACE\output"
          $assemblyName = $Env:CSPROJ_FILE_NAME
          $assemblyVersion = $Env:VERSION

          # Define the target file extensions (with leading dot)
          $validExtensions = @(".cpz", ".clz", ".cplz", ".dll")

          # Create the include patterns for Get-ChildItem -Include
          $includePatterns = $validExtensions | ForEach-Object { "$assemblyName*$_" }

          Write-Output "Target File Extensions: $($validExtensions -join ', ')"
          Write-Output "Include Patterns: $($includePatterns -join ', ')"
          Write-Output "Source Directory: $sourceDir"
          Write-Output "Destination Directory: $destinationDir"
          Write-Output "Assembly Name: $assemblyName"
          Write-Output "Assembly Version: $assemblyVersion"

          # Create the destination directory if it doesn't exist.
          New-Item -ItemType Directory -Force -Path $destinationDir

          Write-Output "Searching for files with extensions $($validExtensions -join ', ') in $sourceDir..."

          # Find files recursively in the source directory with the specified extensions
          # and copy them to the destination directory.
          Get-ChildItem -Path $sourceDir -Recurse | Where-Object {
              $_.Name -like "*$assemblyName*" -and $validExtensions -contains $_.Extension
          } | ForEach-Object {
              Write-Output "Copying $($_.FullName) to $destinationDir"
              $_ | Copy-Item -Destination $destinationDir -Force
          }

          Write-Output "File copy process completed."
          Write-Output "Contents of destination directory ($destinationDir):"
          Get-ChildItem -Path $destinationDir

          Write-Output "Renaming files in $destinationDir to include assembly version '$assemblyVersion'..."

          # Rename the copied files in the destination directory
          # Use Where-Object for more reliable filtering within the specific directory
          Get-ChildItem -Path $destinationDir | Where-Object { $validExtensions -contains $_.Extension } | ForEach-Object {
              $oldName = $_.Name
              $baseName = $_.BaseName
              $extension = $_.Extension # Includes the dot (.)
              $newName = "$baseName.$assemblyVersion$extension" # Just the new filename
              # $newFullName = Join-Path -Path $destinationDir -ChildPath $newName # This line is not needed for Rename-Item
              
              Write-Output "Renaming '$oldName' to '$newName'"
              # Use $newName (just the filename) for the -NewName parameter
              Rename-Item -Path $_.FullName -NewName $newName -Force 
          }

          Write-Output "File renaming process completed."
          Write-Output "Contents of destination directory ($destinationDir):"
          Get-ChildItem -Path $destinationDir

          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "## Copy build output files`n"
          Get-ChildItem -Path $destinationDir | ForEach-Object {
              Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "- $($_.Name)`n"
          }
        
      # Remove any existing nuspec files and create a new one
      - name: Create Nuspec File
        shell: pwsh
        run: |
          # Remove any existing nuspec files
          Get-ChildItem -Path .\ -Filter *.nuspec -Recurse | Remove-Item -Force

          # Create a new nuspec file
          $year = (Get-Date).Year
          $repoFullName = "${{ github.repository }}" # Full repository name, including owner
          $repoName = $repoFullName.Split('/')[-1] # Extracting the repository name part from a URL style path
          $makeModelParts = $repoName -split '-'
          $makeModel = $makeModelParts[1..($makeModelParts.Length - 1)] -join ' ' # Joining all parts after the first dash
          $title = (Get-Culture).TextInfo.ToTitleCase($makeModel)
          $makeModel = $title -replace ' ', '' # Removing spaces for the ID
          $id = "PepperDash.Essentials.Plugin." + $makeModel
          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value "## Create Nuspec File`n"
          Write-Output "Repo: $repoFullName" | Add-Content -Path $env:GITHUB_STEP_SUMMARY
          Write-Output "Repo Name: $repoName" | Add-Content -Path $env:GITHUB_STEP_SUMMARY
          Write-Output "Make/Model: $makeModel" | Add-Content -Path $env:GITHUB_STEP_SUMMARY
          Write-Output "Title: $title" | Add-Content -Path $env:GITHUB_STEP_SUMMARY
          Write-Output "ID: $id" | Add-Content -Path $env:GITHUB_STEP_SUMMARY
          Write-Output "Owner: ${{ github.repository_owner }}" | Add-Content -Path $env:GITHUB_STEP_SUMMARY
          Write-Output "Output Directory: ${{ github.workspace }}\output" | Add-Content -Path $env:GITHUB_STEP_SUMMARY
          $nuspecContent = @"
          <?xml version='1.0' encoding='utf-8'?>
          <package>
            <metadata>
              <id>$id</id>
              <version>${{ env.VERSION }}</version>
              <title>$title</title>
              <authors>PepperDash Technologies</authors>
              <owners>pepperdash</owners>
              <requireLicenseAcceptance>false</requireLicenseAcceptance>
              <license type='file'>LICENSE.md</license>
              <projectUrl>https://github.com/${{ github.repository }}</projectUrl>
              <copyright>Copyright $year</copyright>
              <description>$repoName Epi</description>
              <tags>crestron 3series</tags>
              <repository type='git' url='https://github.com/${{ github.repository }}'/>
            </metadata>
            <files>
              <file src='LICENSE.md' target=''/>
              <file src='README.md' target=''/>
              <file src='.\output\**' target='lib\net35'/>
            </files>
          </package>
          "@
          # Write the nuspec content to a file
          Write-Output $nuspecContent > ${{ github.workspace }}\project.nuspec
          $nuspec_file = (Get-ChildItem *.nuspec -recurse).BaseName
          Write-Output "Nuspec File: $nuspec_file"
          Write-Output "NUSPEC_FILE=$($nuspec_file)" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
      
      # Pulls the nuget builder packages
      - name: Add nuget.exe
        if: ${{ !contains( env.NUSPEC_FILE, 'EssentialsPluginTemplate' ) }}
        uses: nuget/setup-nuget@v2        
      
        # Creating nuget Packages
      - name: Create nuget package
        shell: pwsh
        if: ${{ !contains( env.NUSPEC_FILE, 'EssentialsPluginTemplate' ) }}
        run: |
          if (-not (Test-Path -Path ".\project.nuspec")) {
            Write-Error "NuGet nuspec file not foundCheck if the build process created the package correctly."
            exit 1
          } 
          nuget pack ".\project.nuspec" -version ${{ env.VERSION }} -OutputDirectory .\output
      
      # Pushes to internal github registry
      - name: Setup and Publish to GitHub feed
        shell: pwsh
        run: |
          if (-not (Test-Path -Path ".\output\*.nupkg")) {
            Write-Error "No NuGet package found in the output directory. Check if the build process created the package correctly."
            exit 1
          }          
          if (-not (nuget sources list | Select-String -Pattern "https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json")) {
            nuget sources add -name github -source https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json -username pepperdash -password ${{ secrets.GITHUB_TOKEN }}
          }
          nuget push .\output\*.nupkg -source github -apikey ${{ secrets.GITHUB_TOKEN }}
          Write-Output "GitHub Event: ${{ github.event }}" | Add-Content -Path $env:GITHUB_STEP_SUMMARY

      # Pushes to nuget.org Only if the repo is public and the owner is PepperDash
      - name: Publish to Nuget.org (public repos only) 
        shell: pwsh
        if: github.repository_owner == 'PepperDash' && github.repository.visibility == 'public'
        run: |
          Write-Output "Publishing ${{ github.repository }} to NuGet.org" | Add-Content -Path $env:GITHUB_STEP_SUMMARY
          nuget setApiKey ${{ secrets.NUGET_API_KEY }} -Source https://api.nuget.org/v3/index.json
          nuget push .\output\*.nupkg -Source https://api.nuget.org/v3/index.json

      - name: Skipping publish to Nuget.org (non public repos)        
        if: github.repository_owner != 'PepperDash' || github.repository.visibility != 'public'
        run: Write-Output "Repository is not public, skipping publishing to NuGet.org." | Add-Content -Path $env:GITHUB_STEP_SUMMARY
    
      # Create the release on the source repo
      - name: Get release notes
        uses: actions/download-artifact@v4
        with:
          name: change-log
      
      - name: Upload Release
        id: create_release
        uses: ncipollo/release-action@v1
        with:
          allowUpdates: true
          artifacts: output\*.*(cpz|cplz|clz)
          prerelease: ${{ inputs.channel != '' }}
          tag: ${{ inputs.tag }}
          commit: ${{ github.sha }}
          bodyFile: .\CHANGELOG.md

    