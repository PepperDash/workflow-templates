name: react-npm-push
on:
  workflow_call:
    outputs:
      version:
        description: 'The version of the workflow'
        value: ${{ jobs.get_version.outputs.version }}
      tag:
        description: 'The tag of the workflow'
        value: ${{ jobs.get_version.outputs.tag }}
      newVersion:
        description: 'Was a new version generated?'
        value: ${{ jobs.get_version.outputs.newVersion }}      
      type:
        description: 'The type of version bump'
        value: ${{ jobs.get_version.outputs.type }}
      channel:
        description: 'The channel of the workflow'
        value: ${{ jobs.get_version.outputs.channel }}
      hash:
        description: 'The short SHA of the workflow'
        value: ${{ jobs.get_version.outputs.hash }}
jobs:
  get_version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      tag: ${{ steps.get_version.outputs.tag }}
      hash: ${{ steps.get_version.outputs.hash }}
      channel: ${{ steps.get_version.outputs.channel }}
      newVersion: ${{ steps.get_version.outputs.newVersion }}
      type: ${{ steps.get_version.outputs.type }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - uses: actions/setup-node@v4 
        with:
          node-version: lts/*
          cache: npm

      - name: Create default releaserc if none exists
        run: |
          if [ ! -f ".releaserc.json" ]; then
            echo "No .releaserc.json found, creating default configuration..."
            cat > .releaserc.json << EOF
          {
            "plugins": [
              [
                "@semantic-release/commit-analyzer",
                {
                  "releaseRules": [
                    { "scope": "force-patch", "release": "patch" },
                    { "scope": "no-release", "release": false }
                  ]
                }
              ],
              "@semantic-release/release-notes-generator",    
              ["@semantic-release/changelog", 
                {
                  "changelogFile": "CHANGELOG.md"
                }
              ],
              [
                "@semantic-release/exec",
                {
                  "verifyReleaseCmd": "echo \"newVersion=true\" >> \$GITHUB_OUTPUT",
                  "publishCmd": "echo \"version=\${nextRelease.version}\" >> \$GITHUB_OUTPUT && echo \"tag=\${nextRelease.gitTag}\" >> \$GITHUB_OUTPUT && echo \"type=\${nextRelease.type}\" >> \$GITHUB_OUTPUT && echo \"channel=\${nextRelease.channel}\" >> \$GITHUB_OUTPUT"
                }
              ]
            ],  
            "branches": [
              "main",
              {
                "name": "replace-me-feature-branch",
                "prerelease": "replace-me-prerelease",
                "channel": "replace-me-prerelease"
              }
            ]
          }
          EOF
            echo "Created default .releaserc.json"
          else
            echo "Found existing .releaserc.json, using repository configuration"
          fi
  
      - name: Get branch name
        id: get_branch
        run: |
          branch=${GITHUB_REF#refs/heads/}
          echo "branch=$branch" >> $GITHUB_OUTPUT
          echo "prerelease=${branch//\//-}" >> $GITHUB_OUTPUT
        env:
          GITHUB_REF: ${{ github.ref }}

      - name: Replace branch name in .releaserc.json
        if: steps.get_branch.outputs.branch != 'main'
        uses: jacobtomlinson/gha-find-replace@master
        with:
          find: 'replace-me-feature-branch'
          replace: '${{ steps.get_branch.outputs.branch }}'
          include: '.releaserc.json'

      - name: Replace prerelease name in .releaserc.json
        if: steps.get_branch.outputs.branch != 'main'
        uses: jacobtomlinson/gha-find-replace@master
        with:
          find: 'replace-me-prerelease'
          replace: '${{ steps.get_branch.outputs.prerelease }}'
          include: '.releaserc.json'
  
      - name: Get version number
        id: get_version
        run: |
          npx --package=semantic-release@19.0.5 \
          --package=@semantic-release/commit-analyzer@9.0.2 \
          --package=@semantic-release/release-notes-generator@10.0.3 \
          --package=@semantic-release/changelog@6.0.3 \
          --package=@semantic-release/github@8.0.7 \
          --package=@semantic-release/exec@6.0.3 \
          --package=conventional-changelog-conventionalcommits@4.6.3 \
          -- semantic-release
          echo "hash=$(git rev-parse --short=7 HEAD)" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Install dependencies
        run: npm ci
        
      - name: Build
        run: npm run build  # Adjust this to your actual build command

      - name: Set artifact name
        id: set_names
        run: |
          REPO_NAME=$(echo ${{ github.repository }} | cut -d'/' -f2)
          if [ "${{ steps.get_version.outputs.newVersion }}" == "true" ]; then
            VERSION="${{ steps.get_version.outputs.version }}"
          else
            VERSION="${{ github.ref_name }}"
          fi
          echo "artifact_name=${REPO_NAME}-${VERSION}" >> $GITHUB_OUTPUT
          echo "zip_name=${REPO_NAME}-${VERSION}.zip" >> $GITHUB_OUTPUT

      - name: Create Zip File
        run: |
          zip -r "${{ steps.set_names.outputs.zip_name }}" dist/  # Adjust 'dist' to your build output directory

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.set_names.outputs.artifact_name }}
          path: ${{ steps.set_names.outputs.zip_name }}
          
      - name: Print summary if no new version
        if: steps.get_version.outputs.newVersion != 'true'
        run: |          
          branch=${GITHUB_REF#refs/heads/}
          echo "# Summary" >> $GITHUB_STEP_SUMMARY
          echo "No new version generated" >> $GITHUB_STEP_SUMMARY
          echo "To upload the build from this run, use the following values in the deploy-manual manual action:" >> $GITHUB_STEP_SUMMARY
          echo "version: ${branch//\//-}" >> $GITHUB_STEP_SUMMARY
          echo "hash: ${{ steps.get_version.outputs.hash }}" >> $GITHUB_STEP_SUMMARY

      - name: Upload release notes
        if: steps.get_version.outputs.newVersion == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: change-log
          path: CHANGELOG.md

      - name: Create Release
        if: steps.get_version.outputs.newVersion == 'true'
        uses: ncipollo/release-action@v1
        with:
          allowUpdates: true
          artifactErrorsFailBuild: true
          artifacts: "${{ steps.set_names.outputs.zip_name }},CHANGELOG.md"
          prerelease: ${{ steps.get_version.outputs.channel != '' }}
          tag: ${{ steps.get_version.outputs.tag }}
          commit: ${{ github.sha }}
          bodyFile: ./CHANGELOG.md
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Print results
        if: steps.get_version.outputs.newVersion == 'true'
        run: |
          echo "# Summary" >> $GITHUB_STEP_SUMMARY          
          echo "Version: ${{ steps.get_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "Tag: ${{ steps.get_version.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "New Version: ${{ steps.get_version.outputs.newVersion }}" >> $GITHUB_STEP_SUMMARY
          echo "Channel: ${{ steps.get_version.outputs.channel }}" >> $GITHUB_STEP_SUMMARY
          echo "Type: ${{ steps.get_version.outputs.type }}" >> $GITHUB_STEP_SUMMARY
          echo "Short SHA: ${{ steps.get_version.outputs.hash }}" >> $GITHUB_STEP_SUMMARY


    
      - uses: actions/checkout@v4
        with:
          ref: ${{ steps.get_version.outputs.tag }}
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: lts/*
          registry-url: 'https://npm.pkg.github.com'
          scope: '@${{ github.repository_owner }}'
          cache: npm

      # Create default package.json if it doesn't exist
      - name: Create default package.json if missing
        run: |
          if [ ! -f "package.json" ]; then
            echo "No package.json found, creating default configuration..."
            cat > package.json << EOF
          {
            "name": "${{ github.event.repository.name }}",
            "version": "${{ steps.get_version.outputs.newVersion || '0.0.0' }}",
            "description": "Package for ${{ github.repository }}",
            "main": "dist/index.js",
            "types": "dist/index.d.ts",
            "files": [
              "dist",
              "README.md"
            ],
            "scripts": {
              "build": "tsc",
              "test": "echo \"Error: no test specified\" && exit 1"
            },
            "repository": {
              "type": "git",
              "url": "git+https://github.com/${{ github.repository }}.git"
            },
            "keywords": [],
            "author": "${{ github.repository_owner }}",
            "license": "MIT",
            "bugs": {
              "url": "https://github.com/${{ github.repository }}/issues"
            },
            "homepage": "https://github.com/${{ github.repository }}#readme",
            "publishConfig": {
              "registry": "https://npm.pkg.github.com"
            },
            "peerDependencies": {
              "react": "^18.0.0",
              "react-dom": "^18.0.0"
            },
            "devDependencies": {
              "@types/react": "^18.0.0",
              "@types/react-dom": "^18.0.0",
              "typescript": "^5.0.0"
            }
          }
          EOF
            echo "Created default package.json"

            # Create a basic tsconfig.json if it doesn't exist
            if [ ! -f "tsconfig.json" ]; then
              echo "Creating default tsconfig.json..."
              cat > tsconfig.json << EOF
          {
            "compilerOptions": {
              "target": "es5",
              "module": "commonjs",
              "declaration": true,
              "outDir": "./dist",
              "strict": true,
              "esModuleInterop": true,
              "skipLibCheck": true,
              "forceConsistentCasingInFileNames": true,
              "jsx": "react"
            },
            "include": ["src"],
            "exclude": ["node_modules", "dist"]
          }
          EOF
            fi

            # Create src directory and index file if they don't exist
            if [ ! -d "src" ]; then
              mkdir src
              echo 'export { default } from "./components";' > src/index.ts
              mkdir src/components
              
              # Create a sample component
              cat > src/components/index.tsx << EOF
          import React from 'react';

          interface Props {
            text?: string;
          }

          const Component: React.FC<Props> = ({ text = 'Hello from ${{ github.event.repository.name }}!' }) => {
            return (
              <div>
                {text}
              </div>
            );
          };

          export default Component;
          EOF
            fi
          else
            echo "Found existing package.json, using repository configuration"
          fi

      # Download the build artifact - FIXED VERSION
      - name: Set download artifact name
        id: download_names
        run: |
          REPO_NAME=$(echo ${{ github.repository }} | cut -d'/' -f2)
          if [ "${{ steps.get_version.outputs.newVersion }}" == "true" ]; then
            VERSION="${{ steps.get_version.outputs.version }}"
          else
            VERSION="${{ github.ref_name }}"
          fi
          echo "artifact_name=${REPO_NAME}-${VERSION}" >> $GITHUB_OUTPUT

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ steps.download_names.outputs.artifact_name }}
          path: ./downloaded-artifact

      # Extract the zip file
      - name: Extract build artifact
        run: |
          unzip ./downloaded-artifact/*.zip -d ./
          rm -rf ./downloaded-artifact

      # Update package.json with the new version - FIXED VERSION
      - name: Update package version
        if: steps.get_version.outputs.newVersion == 'true'
        run: npm version ${{ steps.get_version.outputs.version }} --no-git-tag-version

      # Update the package name to include the organization scope
      - name: Update package name
        run: |
          contents="$(jq '.name = "@${{ github.repository_owner }}/${{ github.event.repository.name }}"' package.json)"
          echo "${contents}" > package.json

      # Add the GitHub registry configuration
      - name: Configure npm registry
        run: |
          echo "@${{ github.repository_owner }}:registry=https://npm.pkg.github.com" > .npmrc
          echo "//npm.pkg.github.com/:_authToken=\${NODE_AUTH_TOKEN}" >> .npmrc

      # Publish the package
      - name: Publish package
        run: |
          if [ "${{ steps.get_version.outputs.channel }}" != "" ]; then
            npm publish --tag ${{ steps.get_version.outputs.channel }}
          else
            npm publish
          fi
        env:
          NODE_AUTH_TOKEN: ${{ github.token }}

      - name: Print summary
        run: |
          echo "# NPM Package Published" >> $GITHUB_STEP_SUMMARY
          echo "Version: ${{ steps.get_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "Tag: ${{ steps.get_version.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "Channel: ${{ steps.get_version.outputs.channel || 'latest' }}" >> $GITHUB_STEP_SUMMARY
          echo "Package: @${{ github.repository_owner }}/${{ github.event.repository.name }}" >> $GITHUB_STEP_SUMMARY